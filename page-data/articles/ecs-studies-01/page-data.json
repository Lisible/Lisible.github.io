{"componentChunkName":"component---src-templates-article-template-tsx","path":"/articles/ecs-studies-01","result":{"data":{"markdownRemark":{"html":"<p>In this article series I'll talk about my journey implementing an\n<strong>Entity component system (Ecs)</strong> which is a pattern commonly used in game and\ngame engine development. I will implement it in Rust, and thus these\narticles will be Rust-centered. These articles aren't meant to be a tutorial,\nthese are my personal study notes.</p>\n<h2>The pattern</h2>\n<p>An Entity component system allows to describe a game's entities as a\nset of components. The components are plain data with no logic\nattached to them. The logic is done through systems which will query\nand mutate the components stored in the Ecs.</p>\n<p>Some entity could be a Character entity which has a Sword and a Health\ncomponent. We could then have some system that checks if a Character\nattacks another one and updates the Health component of the attacked entity.</p>\n<p>In summary, there are 3 types of actors in an Ecs:</p>\n<ul>\n<li><strong>Entities</strong>: Uniquely identifiable sets of components</li>\n<li><strong>Components</strong>: The data defining entities</li>\n<li><strong>Systems</strong>: The logic applied to the entities' components</li>\n</ul>\n<p>This pattern has the advantage of easily allowing to add and remove\ncomponents from entities at runtime. It can also be implemented in a\ncache-friendly way and a \"parallel-friendly\" way.</p>\n<h2>Different approaches</h2>\n<p>Writing an Ecs can be challenging in several ways. First, if ensuring\nfast access is wanted, it is required to decide of a smart way of\nstoring the entities and their components. I learnt from <a href=\"https://csherratt.github.io/blog/posts/specs-and-legion/\">this article</a>\nwritten by <a href=\"https://github.com/csherratt\">@csherratt</a> two ways of\nstoring Ecs data that are used in the two most known Ecs library for\nthe Rust programming language.</p>\n<p><strong>Specs</strong> stores each component of the same type in a single storage while\n<strong>Legion</strong> groups them by \"<strong>Archetypes</strong>\". An Archetype is a collection of\nthe components of identically structured entities.</p>\n<p>I won't explore the definition of these concepts more in depth in this article since\n@csherratt's article already fulfill this purpose.</p>\n<p>Another challenging aspect is, as in any data structure and particularly\nthe ones used in a parallel concepts, ensuring its soundness. This is\nespecially true in the context of using a programming language like\nRust which will either scream at you if what you try to do is unsound or\nwill go brrrr if unsound unsafe code is used to get around it.</p>\n<h2>Conclusion</h2>\n<p>This short introduction will be followed by several case studies of\nimplementation details of several Ecs implementations in Rust, such as\nthe previously cited <a href=\"https://github.com/amethyst/specs\"><strong>Specs</strong></a> and <a href=\"https://github.com/amethyst/legion\"><strong>Legion</strong></a>, but also <a href=\"https://github.com/Ralith/hecs\"><strong>hecs</strong></a> or <a href=\"https://github.com/bevyengine/bevy/tree/master/crates/bevy_ecs\"><strong>bevy_ecs</strong></a>\n(which is a fork of hecs).</p>","frontmatter":{"date":"2021-02-04","slug":"/articles/ecs-studies-01","title":"ECS Studies - 01 - What's an Ecs ?"}}},"pageContext":{"slug":"/articles/ecs-studies-01"}},"staticQueryHashes":["3649515864","63159454"]}